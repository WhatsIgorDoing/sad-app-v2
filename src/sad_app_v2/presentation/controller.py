import threading
from pathlib import Path
from typing import Optional

from src.sad_app_v2.core.domain import DocumentGroup, DocumentStatus
from src.sad_app_v2.core.interfaces import (
    CoreError,
    IFileRepository,
    IManifestRepository,
    ManifestReadError,
)
from src.sad_app_v2.core.use_cases.validate_batch import ValidateBatchUseCase
from src.sad_app_v2.infrastructure.excel_reader import ExcelManifestRepository
from src.sad_app_v2.infrastructure.file_system import FileSystemFileRepository


class MainController:
    """
    Controller principal da aplica√ß√£o.
    Coordena as intera√ß√µes entre a View e os Use Cases.
    """

    def __init__(self, view):
        """
        Inicializa o controller.

        Args:
            view: Inst√¢ncia da MainView
        """
        self.view = view
        self._setup_dependencies()
        self._bind_events()

        # Estado da aplica√ß√£o
        self.manifest_path: Optional[Path] = None
        self.source_directory: Optional[Path] = None
        self.last_validation_result: Optional[DocumentGroup] = None

    def _setup_dependencies(self) -> None:
        """
        Configura as depend√™ncias (repositories e use cases).
        """
        # Repositories
        self.manifest_repository: IManifestRepository = ExcelManifestRepository()
        self.file_repository: IFileRepository = FileSystemFileRepository()

        # Use Cases
        self.validate_batch_use_case = ValidateBatchUseCase(
            manifest_repo=self.manifest_repository,
            file_repo=self.file_repository,
        )

    def _bind_events(self) -> None:
        """
        Conecta os eventos da view aos m√©todos do controller.
        """
        # Bot√£o de sele√ß√£o de manifesto
        self.view.manifest_button.configure(command=self._select_manifest_file)

        # Bot√£o de sele√ß√£o de diret√≥rio fonte
        self.view.source_dir_button.configure(command=self._select_source_directory)

        # Bot√£o de valida√ß√£o
        self.view.validate_button.configure(command=self._start_validation)

    def _select_manifest_file(self) -> None:
        """
        Abre dialog para sele√ß√£o do arquivo de manifesto.
        """
        from tkinter import filedialog

        import customtkinter as ctk

        file_path = filedialog.askopenfilename(
            title="Selecionar Manifesto",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")],
        )

        if file_path:
            self.manifest_path = Path(file_path)
            self.view.manifest_entry.delete(0, ctk.END)
            self.view.manifest_entry.insert(0, str(self.manifest_path))
            self._log_message(f"Manifesto selecionado: {self.manifest_path.name}")
            self._update_validate_button_state()

    def _select_source_directory(self) -> None:
        """
        Abre dialog para sele√ß√£o do diret√≥rio fonte.
        """
        from tkinter import filedialog

        import customtkinter as ctk

        directory_path = filedialog.askdirectory(title="Selecionar Diret√≥rio Fonte")

        if directory_path:
            self.source_directory = Path(directory_path)
            self.view.source_dir_entry.delete(0, ctk.END)
            self.view.source_dir_entry.insert(0, str(self.source_directory))
            self._log_message(
                f"Diret√≥rio fonte selecionado: {self.source_directory.name}"
            )
            self._update_validate_button_state()

    def _update_validate_button_state(self) -> None:
        """
        Atualiza o estado do bot√£o de valida√ß√£o baseado nos inputs.
        """
        if self.manifest_path and self.source_directory:
            self.view.validate_button.configure(state="normal")
        else:
            self.view.validate_button.configure(state="disabled")

    def _start_validation(self) -> None:
        """
        Inicia o processo de valida√ß√£o em uma thread separada.
        """
        if not self.manifest_path or not self.source_directory:
            self._log_message(
                "‚ùå Erro: Selecione o manifesto e o diret√≥rio fonte", "ERROR"
            )
            return

        # Desabilita bot√£o durante processamento
        self.view.validate_button.configure(state="disabled", text="Validando...")
        self.view.progress_bar.set(0)

        # Executa valida√ß√£o em thread separada
        thread = threading.Thread(target=self._run_validation, daemon=True)
        thread.start()

    def _run_validation(self) -> None:
        """
        Executa a valida√ß√£o em thread separada.
        """
        try:
            self._log_message("üîÑ Iniciando valida√ß√£o...")
            self.view.progress_bar.set(0.2)

            # Executa o use case
            result = self.validate_batch_use_case.execute(
                manifest_file=self.manifest_path, source_directory=self.source_directory
            )

            self.view.progress_bar.set(0.8)
            self.last_validation_result = result

            # Atualiza a interface na thread principal
            self.view.after(0, self._update_results, result)

        except ManifestReadError as e:
            self._log_message(f"‚ùå Erro no manifesto: {e}", "ERROR")
            self.view.after(0, self._reset_validation_button)
        except CoreError as e:
            self._log_message(f"‚ùå Erro de valida√ß√£o: {e}", "ERROR")
            self.view.after(0, self._reset_validation_button)
        except Exception as e:
            self._log_message(f"‚ùå Erro inesperado: {e}", "ERROR")
            self.view.after(0, self._reset_validation_button)

    def _update_results(self, result: DocumentGroup) -> None:
        """
        Atualiza a interface com os resultados da valida√ß√£o.

        Args:
            result: Resultado da valida√ß√£o
        """
        # Separa arquivos por status
        valid_documents = [
            doc for doc in result.files if doc.status == DocumentStatus.VALIDATED
        ]
        invalid_documents = [
            doc for doc in result.files if doc.status == DocumentStatus.UNRECOGNIZED
        ]

        # Atualiza contadores nos labels
        validated_count = len(valid_documents)
        unrecognized_count = len(invalid_documents)

        self.view.validated_label.configure(
            text=f"üìÑ Arquivos Validados ({validated_count})"
        )
        self.view.unrecognized_label.configure(
            text=f"‚ùì Arquivos N√£o Reconhecidos ({unrecognized_count})"
        )

        # Limpa listas anteriores
        self.view.validated_list.configure(state="normal")
        self.view.validated_list.delete("1.0", "end")

        self.view.unrecognized_list.configure(state="normal")
        self.view.unrecognized_list.delete("1.0", "end")

        # Popula lista de arquivos validados
        for doc in valid_documents:
            self.view.validated_list.insert(
                "end", f"‚úÖ {doc.path.name} ({doc.size_bytes / 1024 / 1024:.1f} MB)\n"
            )

        # Popula lista de arquivos n√£o reconhecidos
        for doc in invalid_documents:
            self.view.unrecognized_list.insert(
                "end", f"‚ùå {doc.path.name} ({doc.size_bytes / 1024 / 1024:.1f} MB)\n"
            )

        # Desabilita edi√ß√£o das listas
        self.view.validated_list.configure(state="disabled")
        self.view.unrecognized_list.configure(state="disabled")

        # Finaliza
        self.view.progress_bar.set(1.0)
        self._log_message(
            f"‚úÖ Valida√ß√£o conclu√≠da! {validated_count} v√°lidos, "
            f"{unrecognized_count} n√£o reconhecidos"
        )

        # Habilita o bot√£o de organizar se h√° arquivos validados
        if validated_count > 0:
            self.view.enable_organize_button()

        self._reset_validation_button()

    def _reset_validation_button(self) -> None:
        """
        Restaura o estado do bot√£o de valida√ß√£o.
        """
        self.view.validate_button.configure(state="normal", text="Validar Lote")

    def _log_message(self, message: str, level: str = "INFO") -> None:
        """
        Adiciona mensagem ao log.

        Args:
            message: Mensagem para adicionar
            level: N√≠vel do log (INFO, ERROR, WARNING)
        """
        import datetime

        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"

        # Adiciona ao log na thread principal
        def update_log():
            self.view.log_textbox.configure(state="normal")
            self.view.log_textbox.insert("end", log_entry)
            self.view.log_textbox.see("end")  # Scroll to bottom
            self.view.log_textbox.configure(state="disabled")

        if threading.current_thread() is threading.main_thread():
            update_log()
        else:
            self.view.after(0, update_log)

    def export_results(self) -> None:
        """
        Exporta os resultados da valida√ß√£o para arquivo.
        TODO: Implementar em vers√£o futura.
        """
        if not self.last_validation_result:
            self._log_message("‚ùå Nenhum resultado para exportar")
            return

        self._log_message("üìÅ Exporta√ß√£o ser√° implementada em vers√£o futura")

    def clear_results(self) -> None:
        """
        Limpa os resultados da valida√ß√£o.
        """
        # Limpa listas
        self.view.validated_list.configure(state="normal")
        self.view.validated_list.delete("1.0", "end")
        self.view.validated_list.configure(state="disabled")

        self.view.unrecognized_list.configure(state="normal")
        self.view.unrecognized_list.delete("1.0", "end")
        self.view.unrecognized_list.configure(state="disabled")

        # Reset contadores
        self.view.validated_label.configure(text="üìÑ Arquivos Validados (0)")
        self.view.unrecognized_label.configure(text="‚ùì Arquivos N√£o Reconhecidos (0)")

        # Reset progresso
        self.view.progress_bar.set(0)

        # Limpa estado
        self.last_validation_result = None

        self._log_message("üßπ Resultados limpos")
